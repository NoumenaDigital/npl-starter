const CUSTOMER: Party = 'customer';
const COMPANY: Party = 'company';

@test
function test_cost(test: Test) {
    p: Product = Product[CUSTOMER, COMPANY](5, 0.85);

    // Compute and verify initial cost
    initialCost: Number = p.computeMonthlyCost[CUSTOMER]();
    test.ok(initialCost == 4.25, "Monthly cost should be correct");
};

@test
function test_illegal_rate_increase(test: Test) {
    p: Product = Product[CUSTOMER, COMPANY](5, 0.85);

    // Attempt an illegal rate increase, and expect failure
    attemptedRateRaise: PcallResult<Unit> = test.pcall(\() returns Unit -> p.conditions.setRate[COMPANY](0.9));

    match (attemptedRateRaise) {
        is PcallFail -> test.ok(true, "Raising the rate should fail")
        else -> test.ok(false, "Expected failure")
    };
};

@test
function test_rate_increase(test: Test) {
    p: Product = Product[CUSTOMER, COMPANY](5, 0.85);

    // Forward the clock, attempt increase
    test.setTime(now().plus(months(1)));
    p.conditions.setRate[COMPANY](0.9);

    // Compute and verify new cost
    newCost: Number = p.computeMonthlyCost[CUSTOMER]();
    test.ok(newCost == 4.5, "Monthly cost should be updated and correct");
};

@test
function test_change_of_conditions(test: Test) {
    p: Product = Product[CUSTOMER, COMPANY](5, 0.85);

    // Compute and verify initial cost
    initialCost: Number = p.computeMonthlyCost[CUSTOMER]();
    test.ok(initialCost == 4.25, "Monthly cost should be correct");

    // Set new conditions
    newCnd: Conditions = Conditions[COMPANY](0.80);
    p.changeConditions[COMPANY, CUSTOMER](newCnd);

    // Compute and verify new cost
    newCost: Number = p.computeMonthlyCost[CUSTOMER]();
    test.ok(newCost == 4.00, "New monthly cost should be correct");
};
